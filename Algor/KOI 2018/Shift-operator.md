# 시프트 연산자 (Shift operator)
시프트 연산도 이해를 제대로 못하고 넘어간 것 같아서 이번 기회에 다시 살펴보고자 한다.

## 위키피디아
영어는 비트 연산 문서에 `Bitwise operators`랑 `Bit shifts`가 같이 있는데 한국어는 두 항목이 따로 있다.

일단 `Bitwise operators`는 넘어가고 시프트 연산자만 다뤄보는 걸로 해야겠다.

영어판으로 보면 네 가지 종류가 나온다.

1. `Arithmetic shift` : 산술 시프트<br>
<blockquote>산술 시프트는 연산자 중 하나로서 특수한 2의 거듭제곱수(2, 4, 8, 16 ... 등)와 관련한 곱셈과 나눗셈을 연산할때 사용된다.</blockquote>
2진법 숫자를 n비트만큼 좌/우로 이동하는 연산이다.<br>
이때 밀려서 새로 생기는 빈칸에는 `0`을 넣고 밀리는 비트는 삭제한다.<br>
![Rotate_left_logically](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5c/Rotate_left_logically.svg/210px-Rotate_left_logically.svg.png)<br>
문서에 있던 그림인데 이해가 잘 되서 가져왔다.
왼쪽(`left`)으로 한 칸씩 시프트하는 예제이다.

2. `Logical shift` : 논리 시프트<br>
뭐가 또 있나 본데 부호비트(`Sign bit`)를 보존하지 않는다고 한다.<br>일단은 패스하고 나중에 다시 살펴봐야겠다.

3. `Circular shift(Rotate no carry)` : 원 시프트<br>
얘는 밀리는 비트를 삭제하는 게 아니라 끝에 걍 붙여준다. 원통처럼 빙그르르 돌아가는 식이다.<br>
![](https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Rotate_left.svg/175px-Rotate_left.svg.png)<br>
이것도 그림으로 보면 이해가 잘 된다.
역시 왼쪽(`left`)으로 한 칸씩 시프트하는 예제이다.

4. `Rotate through carry` : ?????
읔엨 이거는 잘 모르겠다. 언제 시간나면 다시 찾아봐야지...

## 이거 왜 씀
아니 근데 이거 왜 쓰는 걸까?

진짜 훨씬 더 간단한 방법도 많을 텐데 굳이 머리아프게 비트를 계산할 필요가...

사실 이유가 있으니까 쓰는 거였다.

> 어떤 메모리 값을 2의 배수 형태의 상수와 곱하거나 나눌 때에는 곱셈/나눗셈 대신에 산술 시프트를 이용할 수 있다. 또한 많은 CPU에서는 상수 곱셈 등의 연산을 시프트 연산자로 처리하는 것이 산술 논리 장치를 거치는 것보다 빠르기 때문에, 컴파일러에서는 곱셈/나눗셈 연산을 자동적으로 산술 시프트 명령어로 변환한다. [(위키피디아)](https://ko.wikipedia.org/wiki/%EC%82%B0%EC%88%A0_%EC%8B%9C%ED%94%84%ED%8A%B8)

다른 연산자를 사용하는 것보다 훨씬 더 빠르고, 2의 배수 형태의 수와 연산할 때 좋다고 한다.

물론 오늘날의 소프트웨어에서는 별 차이가 없을 수도 있겠지만 `Embedded Programming` 등의 분야에서는 중요할 수도 있겠다는 생각이 들었다. 그러한 환경에서 성능을 위해서 메모리 제한이나 문법이 느슨한 신세대 언어 대신 어셈블리나 C를 사용하는 것과 비슷한 느낌 같다.

https://www.joinc.co.kr/w/Site/C/Documents/Bit_Operation<br>
작성이 끝까지 된 것 같지는 않지만 위 링크의 페이지에서도 비트 연산을 사용하는 이유가 상세하게 잘 나와 있다. 나중에 꼭 다시 읽어봐야지...

## 사용법

1. 왼쪽<br>
<h1><code>값 << 이동할 비트 수</code></h1>

2. 오른쪽<br>
<h1><code>값 >> 이동할 비트 수</code></h1>

예를 들어서 `1`을 왼쪽으로 3번 시프트해보자.<br>
숫자 `1`은 2진수로 `0000 0001`이므로 왼쪽으로 3비트 밀면 `0000 1000`, 즉 숫자 `8`이 될 것이다.

```C
#include <stdio.h>
int main(){
	printf("%d", 1 << 3);
	return 0;
}
// 실행결과 : 8
```

위와 같은 코드를 짜고 실행하면 예상대로 `8`이 나오는 것을 확인할 수 있다.

## 문제
KOI 2016 지역대회 중고등부 16번 문제

`(1점) C나 C++ 언어로 작성된 아래 식들 중에서 값이 다른 것은 무엇인가?`

1. `6^2`
2. `3 ? 36 : 6`
3. `9 << 2`
4. `63 & (~27)`
5. `4 * 9`

5번은 딱 봐도 `4*9=36`

2번은 전에 배운 삼항연산자를 이용한 식인데, `0` 이외의 값이 들어가면 `true`니까 참일 때의 조건이 실행되어 그 값이 `36`이 될 것이다.

4번은 `&(AND)` 연산이랑 `~(NOT)` 연산이 쓰였다.<br>

- `AND` 연산은 두 값의 각 자릿수에서 둘 다 `true`여야 `1`을 계산한다.
- `NOT` 연산은 값의 각 자릿수를 반전한다.

먼저 `(~27)`부터 계산해 보자. `27`을 2진수로 바꾸면 `0001 1011`이 된다. `NOT` 연산을 하면 `1110 0100`, 즉 `228`이 된다.<br>
다음으로 `63`을 2진수로 바꾸면 `0011 1111`이 나온다.<br>
```
1110 0100
0011 1111
---------
0010 0100
```
`AND` 연산을 하면 `0010 0100`, `36`이 나온다.

이제 3번을 보자. `9`를 2진수로 바꾸면 `0000 1001`이니까 2비트 밀면 역시 `0010 0100`, `36`이 나온다.

마지막으로 1번은 `^(XOR)` 연산자가 사용되었다.<br>

- `XOR` 연산은 두 값의 각 자릿수의 값이 달라야 `1`을 계산한다.

`6`, `2`는 2진수로 각각 `0110`, `0010`이다.
```
0110
0010
----
0100
```
어라? 뜬금없이 `4`가 나온다.

따라서 답은 1번이다. 사실 미리 풀어보고 계산하는 순서에 주관을 넣었다. 킄킄<br>
~~아니 왜 이런 문제가 고작 1점이야~~
